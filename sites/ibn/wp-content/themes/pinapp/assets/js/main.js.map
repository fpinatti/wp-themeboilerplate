{"version":3,"sources":["main.js"],"names":["document","addEventListener","btnKnowMoreChurch","querySelector","onClickKnowMore","hiddenSections","querySelectorAll","idx","length","classList","add","ministryGrid","setAttribute","getAttribute","latVideoWrapper","myRequest","Request","fetch","then","response","json","videoId","items","id","innerHTML","pageHash","window","location","hash","history","pushState","setTimeout","substr","dispatchEvent","MouseEvent","onClickMenuItem","evt","tSection","target","targetSection","preventDefault","scrollTo","top","getBoundingClientRect","pageYOffset","behavior","mainHeader","remove","menuItems","sections","menuLinkElement","menuItemUrl","urlSplit","split","sectionName","replace","push","btnSandwich","toggle","observer","IntersectionObserver","entries","forEach","entry","activateMenuItem","isIntersecting","item","section","observe","img","pictureElement","createElement","source1Element","source2Element","imgElement","src","className","parentNode","toString","srcset","media","getLargeImg","filename","substring","lastIndexOf","pathname","alt","appendChild","replaceWith","initFx"],"mappings":"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","file":"main.js","sourceRoot":"..\\..\\assets-src\\js","sourcesContent":["document.addEventListener(\"DOMContentLoaded\", function () {\n\n\t//HOME\n\tvar btnKnowMoreChurch = document.querySelector('.btn-know-more-church a');\n\tonClickKnowMore = function () {\n\t\tvar hiddenSections = document.querySelectorAll('.know-more-section');\n\t\tfor (let idx = 0; idx < hiddenSections.length; ++idx) {\n\t\t\thiddenSections[idx].classList.add('d-block');\n\t\t}\n\t};\n\tif (btnKnowMoreChurch) {\n\t\tbtnKnowMoreChurch.addEventListener('click', onClickKnowMore);\n\t}\n\n\t//GALLERY\n\tvar ministryGrid = document.querySelectorAll('.ministry-grid a');\n\tfor (let idx = 0; idx < ministryGrid.length; ++idx) {\n\t\tministryGrid[idx].setAttribute('data-toggle', 'modal');\n\t\tministryGrid[idx].setAttribute('data-target', ministryGrid[idx].getAttribute('href'));\n\t}\n\n\t//latest video\n\tvar latVideoWrapper = document.querySelector('.latestVideo');\n\tvar myRequest = new Request('https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=UC6kD6-RCkdyeotrh6dMDW3Q&maxResults=1&order=date&type=video&key=AIzaSyCwUFQ5c-XkVxT5daJwrVohk4h6pCjUgdA');\n\tfetch(myRequest)\n\t\t.then(response => response.json())\n\t\t.then(json => {\n\t\t\tvar videoId = json.items[0].id.videoId;\n\t\t\tlatVideoWrapper.innerHTML = `<iframe width=\"100%\" height=\"315\" \n\t\t\tsrc=\"https://www.youtube-nocookie.com/embed/${videoId}\" \n\t\t\tframeborder=\"0\" allow=\"accelerometer; \n\t\t\tautoplay; clipboard-write; encrypted-media; \n\t\t\tgyroscope; picture-in-picture\" \n\t\t\tallowfullscreen></iframe>`;\n\n\t\t});\n\n\n\tvar pageHash = window.location.hash;\n\tif (pageHash) {\n\t\thistory.pushState(null, null, ' ');\n\t\tsetTimeout(function () {\n\t\t\tpageHash = pageHash.substr(1);\n\t\t\tvar element = document.querySelector('[data-section=\"' + pageHash + '\"]');\n\t\t\telement.dispatchEvent(new MouseEvent('click'));\n\t\t}, 2000);\n\t}\n\n\t//MENU\n\tvar onClickMenuItem = function (evt) {\n\t\tvar tSection = evt.target.getAttribute('data-section');\n\t\tvar targetSection = document.querySelector('#' + tSection);\n\t\tif (targetSection) {\n\t\t\tevt.preventDefault();\n\t\t\tif (tSection === 'ministerios') {\n\t\t\t\tbtnKnowMoreChurch.dispatchEvent(new MouseEvent('click'));\n\t\t\t}\n\n\t\t\twindow.scrollTo({\n\t\t\t\ttop: targetSection.getBoundingClientRect().top + window.pageYOffset - 170,\n\t\t\t\tbehavior: 'smooth'\n\t\t\t});\n\t\t\t// targetSection.scrollIntoView({\n\t\t\t// \tinline: 'nearest',\n\t\t\t// \tblock: 'start',\n\t\t\t// \tbehavior: 'smooth'\n\t\t\t// });\n\t\t\tmainHeader.classList.remove('open');\n\t\t}\n\t};\n\n\tvar menuItems = document.querySelectorAll('.menu-item');\n\tvar sections = [];\n\n\tfor (let idx = 0; idx < menuItems.length; ++idx) {\n\t\tlet menuLinkElement = menuItems[idx].querySelector('a');\n\t\tlet menuItemUrl = menuLinkElement.getAttribute('href');\n\t\tlet urlSplit = menuItemUrl.split('/');\n\t\tlet sectionName = urlSplit[urlSplit.length - 2];\n\t\tif (sectionName !== 'estudos') {\n\t\t\tmenuItemUrl = menuItemUrl.replace(sectionName + '/', '#' + sectionName);\n\t\t\tmenuLinkElement.setAttribute('data-section', sectionName);\n\t\t\tsections.push('#' + sectionName);\n\t\t\tmenuLinkElement.setAttribute('href', menuItemUrl);\n\t\t\tmenuLinkElement.addEventListener('click', onClickMenuItem);\n\t\t}\n\t}\n\tconst btnSandwich = document.querySelector('.sandwich-icon');\n\tconst mainHeader = document.querySelector('.main-header');\n\tconst toggleMenu = () => {\n\n\t\tmainHeader.classList.toggle('open');\n\t};\n\n\tbtnSandwich.addEventListener('click', toggleMenu);\n\n\t// detect active sections\n\tlet observer = new IntersectionObserver((entries, observer) => {\n\t\tentries.forEach(entry => {\n\t\t\tif (entry.isIntersecting) {\n\t\t\t\tactivateMenuItem(entry.target.id);\n\t\t\t}\n\t\t});\n\t});\n\tdocument.querySelectorAll(sections).forEach(section => {\n\t\tobserver.observe(section);\n\t});\n\n\t//\n\tfunction activateMenuItem(id) {\n\t\tdocument.querySelectorAll('.menu-item').forEach(item => {\n\t\t\titem.classList.remove('current-menu-item');\n\t\t\tif (id && id === item.querySelector('a').getAttribute('data-section')) {\n\t\t\t\titem.classList.add('current-menu-item');\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t};\n\n\n\t//replace all figures with picture\n\tconst figures = document.querySelectorAll('figure.responsive img');\n\tfigures.forEach(img => {\n\t\tconst pictureElement = document.createElement('picture');\n\t\tconst source1Element = document.createElement('source');\n\t\tconst source2Element = document.createElement('source');\n\t\tconst imgElement = document.createElement('img');\n\t\tconst src = img.getAttribute('src');\n\t\tpictureElement.className = img.parentNode.classList.toString();\n\t\tsource1Element.srcset = src;\n\t\tsource1Element.media = '(max-width: 767px)';\n\t\tsource2Element.srcset = getLargeImg(src);\n\t\tsource2Element.media = '(min-width: 768px)';\n\t\timgElement.src = src;\n\t\timgElement.alt = img.getAttribute('alt');\n\t\tpictureElement.appendChild(source1Element);\n\t\tpictureElement.appendChild(source2Element);\n\t\tpictureElement.appendChild(imgElement);\n\t\timg.parentNode.replaceWith(pictureElement);\n\t});\n\n\tfunction getLargeImg(src) {\n\t\tlet filename = src.substring(src.lastIndexOf('/')+1);\n\t\tlet pathname = src.substring(0,src.lastIndexOf('/'));\n\t\tfilename = filename.split('.');\n\t\tfilename = filename[0] + '-md.' + filename[1];\n\t\treturn pathname + '/' + filename;\n\t}\n\n\t// let options = {\n\t// \troot: document.querySelector('#scrollArea'),\n\t// \trootMargin: '0px',\n\t// \tthreshold: 1.0\n\t//   }\n\n\t//   let observer = new IntersectionObserver(callback, options);\n\n\n\t// parallax\n\t// const titles = document.querySelectorAll('.s-title');\n\t// titles.forEach(title => {\n\t// \tvar text = new Blotter.Text(title.innerText, {\n\t// \t\tfamily : 'Playfair Display',\n\t// \t\tsize : 26,\n\t// \t\tstyle: 'italic',\n\t// \t\tweight: 700,\n\t// \t\tpaddingLeft: 5,\n\t// \t\tpaddingRight: 5,\n\t// \t\tfill : RGBToHex(getComputedStyle(title).color)\n\t// \t});\n\t// \tconsole.log(RGBToHex(getComputedStyle(title).color));\n\t// \tvar material = new Blotter.ChannelSplitMaterial();\n\t// \tmaterial.uniforms.uOffset.value = .1;\n\t// \tmaterial.uniforms.uApplyBlur.value = true;\n\t// \tvar blotter = new Blotter(material, { texts : text });\n\t// \tvar scope = blotter.forText(text);\n\t// \tconst div = document.createElement('div');\n\t// \ttitle.parentNode.insertBefore(div, title);\n\t// \tscope.appendTo(div);\n\t// \tdiv.classList = title.classList;\n\t// \tdiv.classList.remove('sr-only');\n\t// });\n\n\tfunction RGBToHex(rgb) {\n\t\t// Choose correct separator\n\t\tlet sep = rgb.indexOf(\",\") > -1 ? \",\" : \" \";\n\t\t// Turn \"rgb(r,g,b)\" into [r,g,b]\n\t\trgb = rgb.substr(4).split(\")\")[0].split(sep);\n\t\t\n\t\tlet r = (+rgb[0]).toString(16),\n\t\t\tg = (+rgb[1]).toString(16),\n\t\t\tb = (+rgb[2]).toString(16);\n\t\t\n\t\tif (r.length == 1)\n\t\t\tr = \"0\" + r;\n\t\tif (g.length == 1)\n\t\t\tg = \"0\" + g;\n\t\tif (b.length == 1)\n\t\t\tb = \"0\" + b;\n\t\t\n\t\treturn \"#\" + r + g + b;\n\t}\n\n});\n\nwindow.addEventListener(\"load\", () => {\n\tinitFx();\n\n});\n\ninitFx = function () {\n\n\n\t// // we will keep track of all our planes in an array\n\t// let scrollEffect = 0;\n\n\t// // set up our WebGL context and append the canvas to our wrapper\n\t// const curtains = new Curtains({\n\t//     container: \"canvas\",\n\t//     antialias: false, // render targets will disable default antialiasing anyway\n\t//     pixelRatio: Math.min(1.5, window.devicePixelRatio) // limit pixel ratio for performance\n\t// });\n\n\t// curtains.onRender(() => {\n\t//     // update our planes deformation\n\t//     // increase/decrease the effect\n\t//     scrollEffect = curtains.lerp(scrollEffect, 0, 0.05);\n\t// }).onScroll(() => {\n\t//     // get scroll deltas to apply the effect on scroll\n\t//     const delta = curtains.getScrollDeltas();\n\n\t//     // invert value for the effect\n\t//     delta.y = -delta.y;\n\n\t//     // threshold\n\t//     if(delta.y > 100) {\n\t//         delta.y = 100;\n\t//     }\n\t//     else if(delta.y < -100) {\n\t//         delta.y = -100;\n\t//     }\n\n\t//     if(Math.abs(delta.y) > Math.abs(scrollEffect)) {\n\t//         scrollEffect = curtains.lerp(scrollEffect, delta.y, 0.5);\n\t//     }\n\n\t// }).onError(() => {\n\t//     // we will add a class to the document body to display original images\n\t//     document.body.classList.add(\"no-curtains\");\n\t// }).onContextLost(() => {\n\t//     // on context lost, try to restore the context\n\t//     curtains.restoreContext();\n\t// });\n\n\n\t// // get our planes elements\n\t// const planeElements = document.getElementsByClassName(\"wp-block-image\");\n\t// const smallPlaneElements = document.getElementsByClassName(\"wp-block-image\");\n\n\n\t// const distortionTarget = new RenderTarget(curtains);\n\t// const rgbTarget = new RenderTarget(curtains);\n\n\n\t// const vs = `\n\t//     precision mediump float;\n\n\t//     // default mandatory variables\n\t//     attribute vec3 aVertexPosition;\n\t//     attribute vec2 aTextureCoord;\n\n\t//     uniform mat4 uMVMatrix;\n\t//     uniform mat4 uPMatrix;\n\n\t//     uniform mat4 planeTextureMatrix;\n\n\t//     // custom variables\n\t//     varying vec3 vVertexPosition;\n\t//     varying vec2 vTextureMatrixCoord;\n\n\t//     void main() {\n\n\t//         vec3 vertexPosition = aVertexPosition;\n\n\t//         gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);\n\n\t//         // varyings\n\t//         vVertexPosition = vertexPosition;\n\t//         vTextureMatrixCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n\t//     }\n\t// `;\n\n\t// const fs = `\n\t//     precision mediump float;\n\n\t//     varying vec3 vVertexPosition;\n\t//     varying vec2 vTextureMatrixCoord;\n\n\t//     uniform sampler2D planeTexture;\n\n\t//     void main() {\n\t//         // just display our texture\n\t//         gl_FragColor = texture2D(planeTexture, vTextureMatrixCoord);\n\t//     }\n\t// `;\n\n\t// // add our planes and handle them\n\t// for(let i = 0; i < planeElements.length; i++) {\n\t//     const plane = new Plane(curtains, planeElements[i], {\n\t//         vertexShader: vs,\n\t//         fragmentShader: fs,\n\t//     });\n\n\t//     plane.setRenderTarget(distortionTarget);\n\t// }\n\n\t// // add the small planes as well\n\t// for(let i = 0; i < smallPlaneElements.length; i++) {\n\t//     const plane = new Plane(curtains, smallPlaneElements[i], {\n\t//         vertexShader: vs,\n\t//         fragmentShader: fs,\n\t//         texturesOptions: {\n\t//             // textures images will be reduced, use LINEAR_MIPMAP_NEAREST\n\t//             minFilter: curtains.gl.LINEAR_MIPMAP_NEAREST\n\t//         },\n\t//     });\n\n\t//     plane.setRenderTarget(rgbTarget);\n\t// }\n\n\n\t// const distortionFs = `\n\t//     precision mediump float;\n\n\t//     varying vec3 vVertexPosition;\n\t//     varying vec2 vTextureCoord;\n\n\t//     uniform sampler2D uRenderTexture;\n\n\t//     uniform float uScrollEffect;\n\n\t//     void main() {\n\t//         vec2 textureCoords = vTextureCoord;\n\t//         vec2 texCenter = vec2(0.5, 0.5);\n\n\t//         // distort around scene center\n\t//         textureCoords.y += cos((textureCoords.x - texCenter.x) * 3.141592) * uScrollEffect / 500.0;\n\n\t//         gl_FragColor = texture2D(uRenderTexture, textureCoords);\n\t//     }\n\t// `;\n\n\t// const distortionPass = new ShaderPass(curtains, {\n\t//     fragmentShader: distortionFs,\n\t//     renderTarget: distortionTarget,\n\t//     uniforms: {\n\t//         scrollEffect: {\n\t//             name: \"uScrollEffect\",\n\t//             type: \"1f\",\n\t//             value: 0,\n\t//         },\n\t//     },\n\t// });\n\n\t// distortionPass.onRender(() => {\n\t//     // update the uniform\n\t//     distortionPass.uniforms.scrollEffect.value = scrollEffect;\n\t// });\n\n\n\t// const rgbFs = `\n\t//     precision mediump float;\n\n\t//     varying vec3 vVertexPosition;\n\t//     varying vec2 vTextureCoord;\n\n\t//     uniform sampler2D uRenderTexture;\n\n\t//     uniform float uScrollEffect;\n\n\t//     void main() {\n\t//         vec2 textureCoords = vTextureCoord;\n\n\t//         vec2 redTextCoords = vec2(vTextureCoord.x, vTextureCoord.y - uScrollEffect / 300.0);\n\t//         vec2 greenTextCoords = vec2(vTextureCoord.x, vTextureCoord.y - uScrollEffect / 600.0);\n\t//         vec2 blueTextCoords = vec2(vTextureCoord.x, vTextureCoord.y - uScrollEffect / 900.0);\n\n\t//         vec4 red = texture2D(uRenderTexture, redTextCoords);\n\t//         vec4 green = texture2D(uRenderTexture, greenTextCoords);\n\t//         vec4 blue = texture2D(uRenderTexture, blueTextCoords);\n\n\t//         vec4 finalColor = vec4(red.r, green.g, blue.b, min(1.0, red.a + blue.a + green.a));\n\t//         gl_FragColor = finalColor;\n\t//     }\n\t// `;\n\n\t// const rgbPass = new ShaderPass(curtains, {\n\t//     fragmentShader: rgbFs,\n\t//     renderTarget: rgbTarget,\n\t//     depthTest: false, // we need to disable the depth test to display that shader pass on top of the first one\n\t//     uniforms: {\n\t//         scrollEffect: {\n\t//             name: \"uScrollEffect\",\n\t//             type: \"1f\",\n\t//             value: 0,\n\t//         },\n\t//     },\n\t// });\n\n\t// rgbPass.onRender(() => {\n\t//     // update the uniform\n\t//     rgbPass.uniforms.scrollEffect.value = scrollEffect;\n\t// });\n\n\n\t// const blurFs = `\n\t//     precision mediump float;\n\n\t//     varying vec3 vVertexPosition;\n\t//     varying vec2 vTextureCoord;\n\n\t//     uniform sampler2D uRenderTexture;\n\n\t//     uniform float uScrollEffect;\n\t//     uniform vec2 uResolution;\n\n\n\t//     // taken from https://github.com/Jam3/glsl-fast-gaussian-blur\n\t//     vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\t//         vec4 color = vec4(0.0);\n\t//         vec2 off1 = vec2(1.3333333333333333) * direction;\n\t//         color += texture2D(image, uv) * 0.29411764705882354;\n\t//         color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n\t//         color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n\t//         return color;\n\t//     }\n\n\t//     void main() {\n\t//         vec4 original = texture2D(uRenderTexture, vTextureCoord);\n\t//         vec4 blur = blur5(uRenderTexture, vTextureCoord, uResolution, vec2(0.0, 1.0));\n\n\t//         gl_FragColor = mix(original, blur, min(1.0, abs(uScrollEffect) / 5.0));\n\t//     }\n\t// `;\n\n\t// let curtainsBBox = curtains.getBoundingRect();\n\n\t// const blurPass = new ShaderPass(curtains, {\n\t//     fragmentShader: blurFs,\n\t//     uniforms: {\n\t//         scrollEffect: {\n\t//             name: \"uScrollEffect\",\n\t//             type: \"1f\",\n\t//             value: 0,\n\t//         },\n\t//         resolution: {\n\t//             name: \"uResolution\",\n\t//             type: \"2f\",\n\t//             value: [curtainsBBox.width, curtainsBBox.height],\n\t//         },\n\t//     },\n\t// });\n\n\t// blurPass.onRender(() => {\n\t//     // update the uniform\n\t//     blurPass.uniforms.scrollEffect.value = scrollEffect;\n\t// }).onAfterResize(() => {\n\t//     curtainsBBox = curtains.getBoundingRect();\n\t//     blurPass.uniforms.resolution.value = [curtainsBBox.width, curtainsBBox.height];\n\t// });\n};"]}